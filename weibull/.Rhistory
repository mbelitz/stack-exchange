d <- vector[4]
comp <- (a*c+b*d+2*a*d)/(a+b+c+d)^2
return(comp)
}
calc.acc <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
acc <- (a+d)/(a+b+c+d)
return(acc)
}
df <- rand.class()
df <- cbind(df,
f1=apply(df, 1, calc.f1),
accuracy=apply(df, 1, calc.acc),
comp1=apply(df, 1, calc.comp1),
se=(apply(df, 1, calc.acc)-apply(df, 1, calc.f1))^2)
head(df)
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="F1",
color="F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
cor_names=c('a','b','c','d','comp1','f1','se')
cor(df[,cor_names], use='complete.obs')^2
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="support-weighted mean F1",
color="F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
library(ggplot2)
set.seed(5)
rand.class <- function(matrix.count=2000, max=100) {
a <- floor(runif(matrix.count, min=0, max=max))
b <- floor(runif(matrix.count, min=0, max=max))
c <- floor(runif(matrix.count, min=0, max=max))
d <- floor(runif(matrix.count, min=0, max=max))
matrix.data <- data.frame(a,b,c,d)
colnames(matrix.data) <- c('a','b','c','d')
return(matrix.data)
}
calc.f1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
f1 <- (a^2+a*b+c*d+d^2)/(a+b+c+d)^2
return(f1)
}
calc.comp1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
comp <- (a*c+b*d+2*a*d)/(a+b+c+d)^2
return(comp)
}
calc.acc <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
acc <- (a+d)/(a+b+c+d)
return(acc)
}
df <- rand.class()
df <- cbind(df,
f1=apply(df, 1, calc.f1),
accuracy=apply(df, 1, calc.acc),
comp1=apply(df, 1, calc.comp1),
se=(apply(df, 1, calc.acc)-apply(df, 1, calc.f1))^2)
head(df)
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="support-weighted mean F1",
color="SWM F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
cor_names=c('a','b','c','d','comp1','f1','se')
cor(df[,cor_names], use='complete.obs')^2
library(ggplot2)
set.seed(5)
rand.class <- function(matrix.count=2000, max=10) {
a <- floor(runif(matrix.count, min=0, max=max))
b <- floor(runif(matrix.count, min=0, max=max))
c <- floor(runif(matrix.count, min=0, max=max))
d <- floor(runif(matrix.count, min=0, max=max))
matrix.data <- data.frame(a,b,c,d)
colnames(matrix.data) <- c('a','b','c','d')
return(matrix.data)
}
calc.f1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
f1 <- (a^2+a*b+c*d+d^2)/(a+b+c+d)^2
return(f1)
}
calc.comp1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
comp <- (a*c+b*d+2*a*d)/(a+b+c+d)^2
return(comp)
}
calc.acc <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
acc <- (a+d)/(a+b+c+d)
return(acc)
}
df <- rand.class()
df <- cbind(df,
f1=apply(df, 1, calc.f1),
accuracy=apply(df, 1, calc.acc),
comp1=apply(df, 1, calc.comp1),
se=(apply(df, 1, calc.acc)-apply(df, 1, calc.f1))^2)
head(df)
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="support-weighted mean F1",
color="SWM F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
cor_names=c('a','b','c','d','comp1','f1','se')
cor(df[,cor_names], use='complete.obs')^2
df[df$accuracy>.9,]
summary(comp_reg)
comp_reg <- lm(comp1~a+b+c+d)
comp_reg <- lm(comp1~a+b+c+d, data=df)
summary(comp_reg)
library(ggplot2)
set.seed(5)
rand.class <- function(matrix.count=2000, max=100) {
a <- floor(runif(matrix.count, min=0, max=max))
b <- floor(runif(matrix.count, min=0, max=max))
c <- floor(runif(matrix.count, min=0, max=max))
d <- floor(runif(matrix.count, min=0, max=max))
matrix.data <- data.frame(a,b,c,d)
colnames(matrix.data) <- c('a','b','c','d')
return(matrix.data)
}
calc.f1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
f1 <- (a^2+a*b+c*d+d^2)/(a+b+c+d)^2
return(f1)
}
calc.comp1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
comp <- (a*c+b*d+2*a*d)/(a+b+c+d)^2
return(comp)
}
calc.acc <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
acc <- (a+d)/(a+b+c+d)
return(acc)
}
df <- rand.class()
df <- cbind(df,
f1=apply(df, 1, calc.f1),
accuracy=apply(df, 1, calc.acc),
comp1=apply(df, 1, calc.comp1),
se=(apply(df, 1, calc.acc)-apply(df, 1, calc.f1))^2)
head(df)
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="support-weighted mean F1",
color="SWM F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
cor_names=c('a','b','c','d','comp1','f1','se')
cor(df[,cor_names], use='complete.obs')^2
comp_reg <- lm(comp1~a+b+c+d, data=df)
summary(comp_reg)
df[df$accuracy>.9,]
df[df$se<.1,]
df[((df$accuracy>.9) && (df$se<.1)),]
> df[((df$accuracy>.9) && (df$se<.3)),]
df[((df$accuracy>.9) && (df$se<.3)),]
df[((df$accuracy>.4) && (df$se<.5)),]
df[((df$accuracy>.9) && (df$se<.5)),]
df[((df$accuracy>.8) && (df$se<.5)),]
df[((df$accuracy>.6) && (df$se<.25)),]
df[((df$accuracy>.6) && (df$se<.5)),]
df[(df$accuracy>.7),][df$se<.2,]
df[(df$accuracy>.9),][df$se<.1,]
library(ggplot2)
set.seed(5)
rand.class <- function(matrix.count=2000, max=100) {
a <- floor(runif(matrix.count, min=0, max=max))
b <- floor(runif(matrix.count, min=0, max=max))
c <- floor(runif(matrix.count, min=0, max=max))
d <- floor(runif(matrix.count, min=0, max=max))
matrix.data <- data.frame(a,b,c,d)
colnames(matrix.data) <- c('a','b','c','d')
return(matrix.data)
}
calc.f1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
f1 <- (a^2+a*b+c*d+d^2)/(a+b+c+d)^2
return(f1)
}
calc.comp1 <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
comp <- (a*c+b*d+2*a*d)/(a+b+c+d)^2
return(comp)
}
calc.acc <- function(vector) {
a <- vector[1]
b <- vector[2]
c <- vector[3]
d <- vector[4]
acc <- (a+d)/(a+b+c+d)
return(acc)
}
df <- rand.class()
df <- cbind(df,
f1=apply(df, 1, calc.f1),
accuracy=apply(df, 1, calc.acc),
comp1=apply(df, 1, calc.comp1),
se=(apply(df, 1, calc.acc)-apply(df, 1, calc.f1))^2)
head(df)
ggplot(df, aes(x=accuracy,y=f1, color=comp1)) +
geom_point() +
labs(x="accuracy",
y="support-weighted mean F1",
color="SWM F1 component") +
scale_color_gradient(low="#13223a", high="#b3c2d8") +
geom_abline(slope=1, intercept=0)
cor_names=c('a','b','c','d','comp1','f1','se')
cor(df[,cor_names], use='complete.obs')^2
comp_reg <- lm(comp1~a+b+c+d, data=df)
summary(comp_reg)
df[(df$accuracy>.9),][df$se<.1,]
View(df)
x<-df[(df$accuracy>.9),]
y<-x[x$se<.1,]
y
x
grid.arrange(dens.plot, cum.plot, nrow=1)
source('~/Desktop/RP Computing/Stack_Exchange/weibull/weibull.R', echo=TRUE)
setwd("~/Desktop/RP Computing/Stack_Exchange/weibull")
source('~/Desktop/RP Computing/Stack_Exchange/weibull/weibull.R', echo=TRUE)
source('~/Desktop/RP Computing/Stack_Exchange/weibull/weibull.R', echo=TRUE)
dens.plot <- ggplot(time[time$location.index %in% seq(1,3),],
aes(x=time.week)) +
geom_histogram(aes(y=..density..,
fill=location.index),
binwidth=1,
alpha =.35,
position='identity')
for (cnt in seq(1,3)) {
dens.plot <- dens.plot + stat_function(fun=dweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
dens.plot <- dens.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,14,2)) +
scale_y_continuous(limits=c(0,1)) +
scale_fill_discrete(name='location',
labels=c('loc 1','loc 2','loc 3')) +
labs(x='week', y='density') +
ggtitle('fitted pdf') +
guides(color=guide_legend(override.aes=list(alpha=.8))) +
theme_minimal() +
theme(text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'),
legend.background=element_rect(color='black',
size=.2))
#--plot of cumulative data for loc.id subjects (1:3)
cum.plot <- ggplot(dat[dat$loc.id %in% seq(1,3),],
aes(x=time.id,
y=cum.per.plant,
color=loc.id)) +
geom_point()
for (cnt in seq(1,3)) {
cum.plot <- cum.plot + stat_function(fun=pweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
cum.plot <- cum.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,12,2)) +
scale_y_continuous(limits=c(0,1),
position='right') +
labs(x='week', y='cumulative density') +
ggtitle('fitted cdf') +
theme_minimal() +
theme(legend.position="none",
text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'))
#collecting the legend with grob
#--source: https://stackoverflow.com/a/13650878/5099971
get.legend <- function(gplt) {
tmp <- ggplot_gtable(ggplot_build(gplt))
leg <- which(sapply(tmp$grob, function(x) x$name)=='guide-box')
legend <- tmp$grob[[leg]]
return(legend)
}
lgnd <- get.legend(dens.plot)
#bringing the plots together
library(gridExtra)
grid.arrange(dens.plot + theme(legend.position='none'),
lgnd,
cum.plot,
layout_matrix=rbind(c(1,1,1,1,1,1,2,3,3,3,3,3,3),
c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)))
source('~/Desktop/RP Computing/Stack_Exchange/weibull/weibull.R', echo=TRUE)
dens.plot <- ggplot(time[time$location.index %in% seq(1,3),],
aes(x=time.week,
fill=factor(location.index))) +
geom_histogram(aes(y=..density..),
binwidth=1,
alpha =.35,
position='identity')
for (cnt in seq(1,3)) {
dens.plot <- dens.plot + stat_function(fun=dweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
dens.plot <- dens.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,14,2)) +
scale_y_continuous(limits=c(0,1)) +
scale_fill_discrete(name='location',
labels=c('loc 1','loc 2','loc 3')) +
labs(x='week', y='density') +
ggtitle('fitted pdf') +
guides(color=guide_legend(override.aes=list(alpha=.8))) +
theme_minimal() +
theme(text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'),
legend.background=element_rect(color='black',
size=.2))
#--plot of cumulative data for loc.id subjects (1:3)
cum.plot <- ggplot(dat[dat$loc.id %in% seq(1,3),],
aes(x=time.id,
y=cum.per.plant,
color=loc.id)) +
geom_point()
for (cnt in seq(1,3)) {
cum.plot <- cum.plot + stat_function(fun=pweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
cum.plot <- cum.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,12,2)) +
scale_y_continuous(limits=c(0,1),
position='right') +
labs(x='week', y='cumulative density') +
ggtitle('fitted cdf') +
theme_minimal() +
theme(legend.position="none",
text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'))
#collecting the legend with grob
#--source: https://stackoverflow.com/a/13650878/5099971
get.legend <- function(gplt) {
tmp <- ggplot_gtable(ggplot_build(gplt))
leg <- which(sapply(tmp$grob, function(x) x$name)=='guide-box')
legend <- tmp$grob[[leg]]
return(legend)
}
lgnd <- get.legend(dens.plot)
#bringing the plots together
library(gridExtra)
grid.arrange(dens.plot + theme(legend.position='none'),
lgnd,
cum.plot,
layout_matrix=rbind(c(1,1,1,1,1,1,2,3,3,3,3,3,3),
c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)))
time
time[time$location.index %in% seq(1,3),]
dens.plot
col.scheme <- c('red3', 'springgreen4', 'royalblue4')
#--plot of non-cumulative data for location.index subjects (1:3)
library(ggplot2)
dens.plot <- ggplot(time[time$location.index %in% seq(1,3),],
aes(x=time.week,
fill=location.index)) +
geom_histogram(aes(y=..density..),
binwidth=1,
alpha =.35,
position='identity')
for (cnt in seq(1,3)) {
dens.plot <- dens.plot + stat_function(fun=dweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
dens.plot <- dens.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,14,2)) +
scale_y_continuous(limits=c(0,1)) +
scale_fill_discrete(name='location',
labels=c('loc 1','loc 2','loc 3')) +
labs(x='week', y='density') +
ggtitle('fitted pdf') +
guides(color=guide_legend(override.aes=list(alpha=.8))) +
theme_minimal() +
theme(text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'),
legend.background=element_rect(color='black',
size=.2))
#--plot of cumulative data for loc.id subjects (1:3)
cum.plot <- ggplot(dat[dat$loc.id %in% seq(1,3),],
aes(x=time.id,
y=cum.per.plant,
color=loc.id)) +
geom_point()
cum.plot <- cum.plot + scale_color_manual(values = col.scheme) +
scale_fill_manual(values = col.scheme) +
scale_x_continuous(limits=c(0,12),
breaks=seq(0,12,2)) +
scale_y_continuous(limits=c(0,1),
position='right') +
labs(x='week', y='cumulative density') +
ggtitle('fitted cdf') +
theme_minimal() +
theme(legend.position="none",
text=element_text(family='Josefin Sans'),
plot.title=element_text(hjust=.5,
face='italic'),
axis.title=element_text(face='plain',
color='dimgrey'),
axis.text=element_text(color='black'))
for (cnt in seq(1,3)) {
cum.plot <- cum.plot + stat_function(fun=pweibull,
args=list(shape=params[[cnt]][[1]],
scale=params[[cnt]][[2]]),
color=col.scheme[cnt], #simple way of using iteration # for color
alpha=.8)
}
#collecting the legend with grob
#--source: https://stackoverflow.com/a/13650878/5099971
get.legend <- function(gplt) {
tmp <- ggplot_gtable(ggplot_build(gplt))
leg <- which(sapply(tmp$grob, function(x) x$name)=='guide-box')
legend <- tmp$grob[[leg]]
return(legend)
}
lgnd <- get.legend(dens.plot)
#bringing the plots together
library(gridExtra)
grid.arrange(dens.plot + theme(legend.position='none'),
lgnd,
cum.plot,
layout_matrix=rbind(c(1,1,1,1,1,1,2,3,3,3,3,3,3),
c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)))
